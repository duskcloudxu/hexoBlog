---
title: leetcodeList-array
date: 2019-11-24 21:56:45
tags:
- 刷题
- Leetcode

---

# List

|          |                                                              |                                          |            |      |
| -------- | ------------------------------------------------------------ | ---------------------------------------- | ---------- | ---- |
| 基础     |                                                              |                                          |            |      |
| 27       | [Remove Element](https://leetcode.com/problems/remove-element/) | [视频讲解](https://cspiration.com/login) | Done       |      |
| 26       | [Remove Duplicates from Sorted Array](https://leetcode.com/problems/remove-duplicates-from-sorted-array/description/) | [视频讲解](https://cspiration.com/login) | Done       |      |
| 80       | [Remove Duplicates from Sorted Array II](https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/description/) | [视频讲解](https://cspiration.com/login) | Done       |      |
| 277      | [Find the Celebrity](https://leetcode.com/problems/find-the-celebrity/description/) | [视频讲解](https://cspiration.com/login) | Prime      |      |
| 189      | [Rotate Array](https://leetcode.com/problems/rotate-array/description/) | [视频讲解](https://cspiration.com/login) | Done       |      |
| 41       | [First Missing Positive](https://leetcode.com/problems/first-missing-positive/description/) | [视频讲解](https://cspiration.com/login) | Done       |      |
| 299      | [Bulls and Cows](https://leetcode.com/problems/bulls-and-cows/) | [视频讲解](https://cspiration.com/login) | DONE       |      |
| 134      | [Gas Station](https://leetcode.com/problems/gas-station/description/) | [视频讲解](https://cspiration.com/login) | Done       |      |
| 118      | [Pascal's Triangle](https://leetcode.com/problems/pascals-triangle/description/) | [视频讲解](https://cspiration.com/login) | 很少考     |      |
| 119      | [Pascal's Triangle II](https://leetcode.com/problems/pascals-triangle-ii/description/) | [视频讲解](https://cspiration.com/login) | 很少考     |      |
| 169      | [Majority Element](https://leetcode.com/problems/majority-element/description/) | [视频讲解](https://cspiration.com/login) | 很少考     |      |
| 229      | [Majority Element II](https://leetcode.com/problems/majority-element-ii/description/) | [视频讲解](https://cspiration.com/login) | 很少考     |      |
| 274      | [H-Index](https://leetcode.com/problems/h-index/description/) | [视频讲解](https://cspiration.com/login) | Done       |      |
| 275      | [H-Index II](https://leetcode.com/problems/h-index-ii/description/) | [视频讲解](https://cspiration.com/login) | Done       |      |
| 243      | [Shortest Word Distance](https://leetcode.com/problems/shortest-word-distance/description/) | [视频讲解](https://cspiration.com/login) | Done       |      |
| 244      | [Shortest Word Distance II](https://leetcode.com/problems/shortest-word-distance-ii/description/) | [视频讲解](https://cspiration.com/login) | Done       |      |
| 245      | [Shortest Word Distance III](https://leetcode.com/problems/shortest-word-distance-iii/description/) | [视频讲解](https://cspiration.com/login) | Done       |      |
| 217      | [Contains Duplicate](https://leetcode.com/problems/contains-duplicate/description/) | [视频讲解](https://cspiration.com/login) | Done       |      |
| 219      | [Contains Duplicate II](https://leetcode.com/problems/contains-duplicate-ii/description/) | [视频讲解](https://cspiration.com/login) | Done       |      |
| 220      | [Contains Duplicate III](https://leetcode.com/problems/contains-duplicate-iii/description/) | [视频讲解](https://cspiration.com/login) | 很少考     |      |
| 55       | [Jump Game](https://leetcode.com/problems/jump-game/description/) | [视频讲解](https://cspiration.com/login) | Done       |      |
| 45       | [Jump Game II](https://leetcode.com/problems/jump-game-ii/description/) | [视频讲解](https://cspiration.com/login) | Done       |      |
| 121      | [Best Time to Buy and Sell Stock](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/description/) | [视频讲解](https://cspiration.com/login) | Done       |      |
| 122      | [Best Time to Buy and Sell Stock II](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/description/) | [视频讲解](https://cspiration.com/login) | Done       |      |
| 123      | [Best Time to Buy and Sell Stock III](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/description/) | [视频讲解](https://cspiration.com/login) | Done       |      |
| 188      | [Best Time to Buy and Sell Stock IV](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/description/) | [视频讲解](https://cspiration.com/login) |            |      |
| 309      | [Best Time to Buy and Sell Stock with Cooldown](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/description/) | [视频讲解](https://cspiration.com/login) |            |      |
| 11       | [Container With Most Water](https://leetcode.com/problems/container-with-most-water/description/) | [视频讲解](https://cspiration.com/login) | Done       |      |
| 42       | [Trapping Rain Water](https://leetcode.com/problems/trapping-rain-water/description/) | [视频讲解](https://cspiration.com/login) | Done       |      |
| 334      | [Increasing Triplet Subsequence](https://leetcode.com/problems/increasing-triplet-subsequence/description/) | [视频讲解](https://cspiration.com/login) | Done       |      |
| 128      | [Longest Consecutive Sequence](https://leetcode.com/problems/longest-consecutive-sequence/description/) | [视频讲解](https://cspiration.com/login) | Done       |      |
| 164      | [Maximum Gap](https://leetcode.com/problems/maximum-gap/description/) | [视频讲解](https://cspiration.com/login) | radix Sort |      |
| 287      | [Find the Duplicate Number](https://leetcode.com/problems/find-the-duplicate-number/description/) | [视频讲解](https://cspiration.com/login) | Done       |      |
| 135      | [Candy](https://leetcode.com/problems/candy/description/)    | [视频讲解](https://cspiration.com/login) | 很少考     |      |
| 330      | [Patching Array](https://leetcode.com/problems/patching-array/description/) | [视频讲解](https://cspiration.com/login) | 很少考     |      |
| 提高     |                                                              |                                          |            |      |
| 4        | [Median of Two Sorted Arrays](https://leetcode.com/problems/median-of-two-sorted-arrays/description/) | [视频讲解](https://cspiration.com/login) | 很少考     |      |
| 321      | [Create Maximum Number](https://leetcode.com/problems/create-maximum-number/description/) | [视频讲解](https://cspiration.com/login) | 很少考     |      |
| 327      | [Count of Range Sum](https://leetcode.com/problems/count-of-range-sum/description/) | [视频讲解](https://cspiration.com/login) |            |      |
| 289      | [Game of Life](https://leetcode.com/problems/game-of-life/description/) | [视频讲解](https://cspiration.com/login) |            |      |
| Interval |                                                              |                                          |            |      |
| 57       | [Insert Interval](https://leetcode.com/problems/insert-interval/description/) | [视频讲解](https://cspiration.com/login) |            |      |
| 56       | [Merge Intervals](https://leetcode.com/problems/merge-intervals/description/) | [视频讲解](https://cspiration.com/login) |            |      |
| 252      | [Meeting Rooms](https://leetcode.com/problems/meeting-rooms/description/) | [视频讲解](https://cspiration.com/login) |            |      |
| 253      | [Meeting Rooms II](https://leetcode.com/problems/meeting-rooms-ii/description/) | [视频讲解](https://cspiration.com/login) |            |      |
| 352      | [Data Stream as Disjoint Intervals](https://leetcode.com/problems/data-stream-as-disjoint-intervals/description/) | [视频讲解](https://cspiration.com/login) | TreeMap    |      |
| Counter  |                                                              |                                          |            |      |
| 239      | [Sliding Window Maximum](https://leetcode.com/problems/sliding-window-maximum/description/) | [视频讲解](https://cspiration.com/login) |            |      |
| 295      | [Find Median from Data Stream](https://leetcode.com/problems/find-median-from-data-stream/description/) | [视频讲解](https://cspiration.com/login) |            |      |
| 53       | [Maximum Subarray](https://leetcode.com/problems/maximum-subarray/description/) | [视频讲解](https://cspiration.com/login) |            |      |
| 325      | [Maximum Size Subarray Sum Equals k](https://leetcode.com/problems/maximum-size-subarray-sum-equals-k/) | [视频讲解](https://cspiration.com/login) |            |      |
| 209      | [Minimum Size Subarray Sum](https://leetcode.com/problems/minimum-size-subarray-sum/description/) | [视频讲解](https://cspiration.com/login) |            |      |
| 238      | [Product of Array Except Self](https://leetcode.com/problems/product-of-array-except-self/description/) | [视频讲解](https://cspiration.com/login) |            |      |
| 152      | [Maximum Product Subarray](https://leetcode.com/problems/maximum-product-subarray/description/) | [视频讲解](https://cspiration.com/login) |            |      |
| 228      | [Summary Ranges](https://leetcode.com/problems/summary-ranges/description/) | [视频讲解](https://cspiration.com/login) |            |      |
| 163      | [Missing Ranges](https://leetcode.com/problems/missing-ranges/description/) | [视频讲解](https://cspiration.com/login) |            |      |
| Counter  |                                                              |                                          |            |      |
| 88       | [Merge Sorted Array](https://leetcode.com/problems/merge-sorted-array/description/) | [视频讲解](https://cspiration.com/login) |            |      |
| 75       | [Sort Colors](https://leetcode.com/problems/sort-colors/description/) | [视频讲解](https://cspiration.com/login) |            |      |
| 283      | [Move Zeroes](https://leetcode.com/problems/move-zeroes/description/) | [视频讲解](https://cspiration.com/login) |            |      |
| 376      | [Wiggle Subsequence](https://leetcode.com/problems/wiggle-subsequence/description/) | [视频讲解](https://cspiration.com/login) |            |      |
| 280      | [Wiggle Sort](https://leetcode.com/problems/wiggle-sort/description/) | [视频讲解](https://cspiration.com/login) |            |      |
| 324      | [Wiggle Sort II](https://leetcode.com/problems/wiggle-sort-ii/description/) | [视频讲解](https://cspiration.com/login) |            |      |
| 278      | [First Bad Version](https://leetcode.com/problems/first-bad-version/description/) | [视频讲解](https://cspiration.com/login) |            |      |
| 35       | [Search Insert Position](https://leetcode.com/problems/search-insert-position/description/) | [视频讲解](https://cspiration.com/login) |            |      |
| 33       | [Search in Rotated Sorted Array](https://leetcode.com/problems/search-in-rotated-sorted-array/description/) | [视频讲解](https://cspiration.com/login) |            |      |
| 81       | [Search in Rotated Sorted Array II](https://leetcode.com/problems/search-in-rotated-sorted-array-ii/description/) | [视频讲解](https://cspiration.com/login) |            |      |
| 153      | [Find Minimum in Rotated Sorted Array](https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/description/) | [视频讲解](https://cspiration.com/login) |            |      |
| 154      | [Find Minimum in Rotated Sorted Array II](https://leetcode.com/problems/find-minimum-in-rotated-sorted-array-ii/description/) | [视频讲解](https://cspiration.com/login) |            |      |
| 162      | [Find Peak Element](https://leetcode.com/problems/find-peak-element/description/) | [视频讲解](https://cspiration.com/login) |            |      |
| 374      | [Guess Number Higher or Lower](https://leetcode.com/problems/guess-number-higher-or-lower/) | [视频讲解](https://cspiration.com/login) |            |      |
| 34       | [Find First and Last Position of Element in Sorted Array](https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/description/) | [视频讲解](https://cspiration.com/login) |            |      |
| 349      | [Intersection of Two Arrays](https://leetcode.com/problems/intersection-of-two-arrays/description/) | [视频讲解](https://cspiration.com/login) |            |      |
| 350      | [Intersection of Two Arrays II](https://leetcode.com/problems/intersection-of-two-arrays-ii/description/) | [视频讲解](https://cspiration.com/login) |            |      |
| 315      | [Count of Smaller Numbers After Self](https://leetcode.com/problems/count-of-smaller-numbers-after-self/description/) | [视频讲解](https://cspiration.com/login) |            |      |
| 300      | [Longest Increasing Subsequence](https://leetcode.com/problems/longest-increasing-subsequence/description/) | [视频讲解](https://cspiration.com/login) |            |      |
| 354      | [Russian Doll Envelopes](https://leetcode.com/problems/russian-doll-envelopes/description/) | [视频讲解](https://cspiration.com/login) |            |      |

# explanations and reflection

## 274 ,275 H-Index

### Description

274. H-Index

Medium

484810FavoriteShare

Given an array of citations (each citation is a non-negative integer) of a researcher, write a function to compute the researcher's h-index.

According to the [definition of h-index on Wikipedia](https://en.wikipedia.org/wiki/H-index): "A scientist has index *h* if *h* of his/her *N* papers have **at least** *h* citations each, and the other *N − h* papers have **no more than** *h* citations each."

**Example:**

```
Input: citations = [3,0,6,1,5]
Output: 3 
Explanation: [3,0,6,1,5] means the researcher has 5 papers in total and each of them had 
             received 3, 0, 6, 1, 5 citations respectively. 
             Since the researcher has 3 papers with at least 3 citations each and the remaining 
             two with no more than 3 citations each, her h-index is 3.
```

**Note:** If there are several possible values for *h*, the maximum one is taken as the h-index.

### Explanations

That is an interesting question, and the main challenge is to understand the new conception brought in description: `The H-index`.

It says that, Given an array of citation numbers `citi`,  an h-index is an number `h` that within the interval `[0,citi.length]` so that there are `h` paper has citations `c` >= `h`, and remaining papers has `c`<=`h`.  

#### Analysis

First of all, this definition is way too complicated, let's find a way to simplify it. 

The beginning of problem analysis is always find a certifier. Given an number h,  We examine it by iterates the whole array, and count the number of paper that has citations less or equal to `h`, namely $Num_{under}$, and number$Num_{upper}$ for papers that has citations above or equal to `h`. if $Num_{upper}$==`h`, then it is an valid `H-index`.

Emmm, I see, it is an NP problem! (LOL)

Okay, to be serious, now we knows how to examine the answer, and let's talk about more different situations. For example, we could easily know that if $Num_{upper}$ is smaller then `h`, the `h` must be bigger than any `H-index`. But what if we find $Num_{upper}$ is bigger then h? Is there any way to find the right `H-index`?



The most naïve method is to increase `h` by one, and iterate the whole array to check if $Number_{upper}$ decreased. If it really decreased, and currently get `h`=$Num_{upper}$ , okay we get the right `H-index`. if $Num_{upper}$ is still the same or it decreased but still bigger than `h` , we continuously decrease `h`, since `h` increases and $Num_{upper}$ decreases, they would become equal eventually. 



Do we really need to iterate the whole array in each increase? meh...let's reconsider our model: Set $S_{upper}$ for papers with citations >= `h`, and set $S_{under}$for papers with citations <=`h`, initial h=0, so $|S_{upper}|=|citi|$ , now we have a set $Gree$. As the name, we put the paper with maximum citation among the remaining papers with citations >=`h` into $Gree$ each time `h` increases, and when there is no such paper, we say the `h` is the max `h-index`. Since each time we select the paper with max citation, we just need to sort the array in descending order and iterator over it. 

#### Follow Up

275 says that if give you an ordered array……okay, then go for binary search, apparently.

### code

``` C++
class Solution {
public:
    int hIndex(vector<int>& citations) {
        sort(citations.begin(),citations.end(),[](auto a,auto b){return a>b;});
        int h=0;
        for(int i=0;i<citations.size();i++){
            if(citations[i]>=h+1)h++;
        }
        return h;
        
    }
};
```

## 45 jump game II

> That is why I do not like leetcode hard, normally there would only be one way out, and it's only depends on whether you have an "a-ha" moment or not.

Hard

169994FavoriteShare

Given an array of non-negative integers, you are initially positioned at the first index of the array.

Each element in the array represents your maximum jump length at that position.

Your goal is to reach the last index in the minimum number of jumps.

**Example:**

```
Input: [2,3,1,1,4]
Output: 2
Explanation: The minimum number of jumps to reach the last index is 2.
    Jump 1 step from index 0 to 1, then 3 steps to the last index.
```

**Note:**

You can assume that you can always reach the last index.

### Explanations

The basic idea is straightforward, use DP to update the minimum jump number for each sub problem dp[i], and the time complexity upper bound is $O(N^2)$. Yet the data here is too large for an algorithm of this time complexity, and that is where our trick is.

Firstly, our basic idea is to update the optimal value of each position by the min jump number, e.g. for an array:`[2,3,1,1,4]`, when we start iterating at the first position, the dp array would be like `[0,inf,inf,inf,inf]`, and obviously if we start from index 0 to other position we would get this dp array `[0,1,1,inf,inf]`, and then we process index 1 and the result should be `[0,1,1,2,2]` and we process index 2 and son on. Note that the dp recurrence formulate is 
$$
dp[i]=min(dp[i],jumpNumFromCurrentPosition+1)
$$
In plain English, the optimal value of an index $i$ is the minimum jumps number plus 1 of all the positions could reach to index $i$.

As you can see, the time complexity of this basic algorithm is $O(N^2)$ since in the worst case, each position would reach to all the following position, and that would be $N, N-1,N-2,...,1$ calculations, and that is $O(N^2)$.

And our goal is to optimize this update mechanism. In the update step, we update the following dp[i] linearly, and that is what we want to optimize. The most brute-force way is to use an segment tree, which could make range update in $O(logn)$.  So the final time complexity of this problem would be $O(nlogn)$, and it would be painful to write a segment tree by yourself in an interview without a template.

Other solutions, which only works for this problem, is to make an "lazy update". we maintain an interval where the minimum jump number in the interval is equal or below an certain number $C$. We continuously put new element into that interval and update $C$ lazily, and immediately stop when the last position is included into the interval.



## 11. Container With Most Water



Medium

4434496FavoriteShare

Given *n* non-negative integers *a1*, *a2*, ..., *an* , where each represents a point at coordinate (*i*, *ai*). *n* vertical lines are drawn such that the two endpoints of line *i* is at (*i*, *ai*) and (*i*, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.

**Note:** You may not slant the container and *n* is at least 2.

 

![img](https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/17/question_11.jpg)

The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.

 

**Example:**

```
Input: [1,8,6,2,5,4,8,3,7]
Output: 49
```

### Explanations

TBH, I am quite confused at the beginning since I just dig deep in DP and Greedy, and only found that those do not work. After checked the optimal solutions for this problem, I found that I am not good at two pointers and decide to design a kind of analysis pattern for two pointer problem.



First of all, I claim that, the essence of two pointer method is to eliminate candidate optimal solutions in the solution space. In other word, you prove that your solution is better than some other solutions in the solution space, so you could save time of checking whether they are optimal solution or not, for you have checked a better solution( which is, the current solution.)



Secondly, there are two kinds of two pointers method, the first is to set both the head and rear pointers at the first element in the array(or the last, basically the same), and another is to set the head pointer at the first element and the rear pointer at the last element and "shrink" the interval formed by the head pointer and the rear pointer.



Therefore, maybe we could just try both two method and see whether we could find a way to eliminate the candidate solution. In other words, try to prove that the current solution is better than some other unchecked solutions in the solution space.

## 334 Increasing Triplet Subsequence

Medium

Given an unsorted array return whether an increasing subsequence of length 3 exists or not in the array.

Formally the function should:

> Return true if there exists *i, j, k*
> such that *arr[i]* < *arr[j]* < *arr[k]* given 0 ≤ *i* < *j* < *k* ≤ *n*-1 else return false.

**Note:** Your algorithm should run in O(*n*) time complexity and O(*1*) space complexity.

**Example 1:**

```
Input: [1,2,3,4,5]
Output: true
```

**Example 2:**

```
Input: [5,4,3,2,1]
Output: false
```

### explanations

it's very intuitive to come up with a brute force algorithm where you record the number of previous smaller element for each element in the array, like `[1,2,3,4,5]`=>`[0,1,2,3,4]`. Based on that, we notice that we only care about there is such 3 elements i,j,k that *arr[i]* < *arr[j]* < *arr[k]* given i<j<k. In other words, we care about whether there is a element that has a previous smaller element that has a previous smaller element. 



Back to the brute force algorithm, and we name the mapped array `[0,1,2,3,4]` as `previousSmallerArray`(`PSA` as abbreviation ). We observe it, and we guess, if there is an element bigger than 2 in `PSA`, then we could found the subsequence we want. However, it is not guaranteed for the counter example `[2,1,3]`=>`[0,0,2]` and there is not a valid subsequence for this question.



Ok, now we found that the most obvious idea is wrong, then what should we do next? Aare we in the totally wrong direction? Maybe we just need some small modification. Look back at the definition, we could see that the middle index, j, is the critical point: it takes the role linking i and k, and what is the cost of finding all the j? Well, it should take $O(n^2)$ to find a valid pair of $i,j$, but it would cost linear time to find if an index could be a $j$: Start iterating from beginning and use a variable $Min$ to record the current minimum number. In each iteration, try to compare variable $Min$ and current value, if the element is bigger than the $Min$, the index of this element should be a candidate $j$.



So this is an interesting part of algorithm, finding an exact pair and finding the existence of a pair is quit different, and the latter could be done in linear time.



Things become clear now, and we just use the same strategy to iterator the array again, but at this time, we aim for $k$, and a valid $k$ should has a prior $j$ that $arr[j]<arr[k]$, and it could also be completed in linear time by recording a minimum $arr[j]$.

### Code

```C++
class Solution {
public:
    bool increasingTriplet(vector<int>& nums) {
        if(nums.size()<3)return false;
        vector<int>smallerNum(nums.size(),0);
        int minn=nums[0];
        for(int i=0;i<nums.size();i++){
            if(nums[i]>minn){
                smallerNum[i]++;
            }
            minn=min(minn,nums[i]);
        }
        
        int secondSmall=-1;
        for(int i=0;i<nums.size();i++){
            if(smallerNum[i]>0){
                secondSmall=i;
                break;
            }
        }
        if(secondSmall==-1)return false;
        for(int i=secondSmall+1;i<nums.size();i++){
            if(nums[i]>nums[secondSmall])return true;
            if(nums[secondSmall]>nums[i]&&smallerNum[i]>0)secondSmall=i;
        }
        return false;
        
    }
};
```



## 128  [Longest Consecutive Sequence](https://leetcode.com/problems/longest-consecutive-sequence/description/)















